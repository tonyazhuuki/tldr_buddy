"""
Archetype Response System for Telegram Voice-to-Insight Bot

Implements the 4-archetype response system with auto-selection based on emotion analysis
and context-aware response generation following mythological personality patterns.
"""

import asyncio
import json
import logging
import os
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass

import openai
from openai import OpenAI

from emotion_analyzer import EmotionScores

logger = logging.getLogger(__name__)


@dataclass
class ArchetypeResponse:
    """Response generated by a specific archetype"""
    archetype: str
    responses: List[str]
    signature: str
    processing_time: Optional[float] = None
    error_message: Optional[str] = None


class ArchetypeSelector:
    """
    Auto-selection algorithm for choosing appropriate archetype based on emotion scores.
    
    Implements priority-based selection following creative specifications:
    EMPATH > TRICKSTER > META-SAGE > CRAZY-WISDOM (default)
    """
    
    def __init__(self):
        # Thresholds from creative specifications
        self.thresholds = {
            'sarcasm_high': 0.7,
            'toxicity_high': 0.6,
            'manipulation_high': 0.5,
            'complexity_threshold': 0.4  # For META-SAGE selection
        }
    
    def select_archetype(self, emotion_scores: EmotionScores) -> Tuple[str, str]:
        """
        Auto-select archetype based on emotion analysis scores.
        
        Args:
            emotion_scores: EmotionScores object with analysis results
            
        Returns:
            Tuple of (archetype_name, selection_reason)
        """
        if emotion_scores.error_message:
            return 'CRAZY-WISDOM', 'выбран по умолчанию (ошибка анализа эмоций)'
        
        sarcasm = emotion_scores.sarcasm
        toxicity = emotion_scores.toxicity
        manipulation = emotion_scores.manipulation
        
        # Priority 1: EMPATH for toxic/manipulative content
        if toxicity >= self.thresholds['toxicity_high'] or manipulation >= self.thresholds['manipulation_high']:
            if toxicity >= self.thresholds['toxicity_high'] and manipulation >= self.thresholds['manipulation_high']:
                return 'EMPATH', 'высокие токсичность и манипуляция'
            elif toxicity >= self.thresholds['toxicity_high']:
                return 'EMPATH', 'высокая токсичность'
            else:
                return 'EMPATH', 'высокая манипуляция'
        
        # Priority 2: TRICKSTER for high sarcasm
        if sarcasm >= self.thresholds['sarcasm_high']:
            return 'TRICKSTER', 'высокий сарказм'
        
        # Priority 3: META-SAGE for moderate emotional complexity
        if any(score >= self.thresholds['complexity_threshold'] for score in [sarcasm, toxicity, manipulation]):
            complex_emotions = []
            if sarcasm >= self.thresholds['complexity_threshold']:
                complex_emotions.append('сарказм')
            if toxicity >= self.thresholds['complexity_threshold']:
                complex_emotions.append('токсичность')
            if manipulation >= self.thresholds['complexity_threshold']:
                complex_emotions.append('манипуляция')
            
            return 'META-SAGE', f'умеренная сложность: {", ".join(complex_emotions)}'
        
        # Default: CRAZY-WISDOM for neutral/complex content
        return 'CRAZY-WISDOM', 'нейтральный контент или сложная ситуация'
    
    def get_archetype_button_info(self) -> Dict[str, Dict[str, str]]:
        """Get button information for manual archetype selection"""
        return {
            'EMPATH': {'emoji': '🤗', 'description': 'Заботливая поддержка'},
            'META-SAGE': {'emoji': '🧙', 'description': 'Мудрые инсайты'},
            'TRICKSTER': {'emoji': '🃏', 'description': 'Игривый вызов'},
            'CRAZY-WISDOM': {'emoji': '☯️', 'description': 'Дзен-парадоксы'}
        }


class ArchetypeConfigLoader:
    """Loads and manages archetype configuration files"""
    
    def __init__(self, modes_dir: str = "archetypes"):
        self.modes_dir = Path(modes_dir)
        self.archetype_configs = {}
        self.load_archetype_configs()
    
    def load_archetype_configs(self):
        """Load all archetype configuration files"""
        archetype_files = {
            'EMPATH': 'empath.json',
            'META-SAGE': 'meta-sage.json',
            'TRICKSTER': 'trickster.json',
            'CRAZY-WISDOM': 'crazy-wisdom.json'
        }
        
        for archetype, filename in archetype_files.items():
            config_path = self.modes_dir / filename
            try:
                if config_path.exists():
                    with open(config_path, 'r', encoding='utf-8') as f:
                        config = json.load(f)
                        self.archetype_configs[archetype] = config
                        logger.info(f"Loaded {archetype} archetype configuration")
                else:
                    logger.warning(f"Archetype config not found: {config_path}")
            except Exception as e:
                logger.error(f"Failed to load {archetype} config: {e}")
    
    def get_archetype_config(self, archetype: str) -> Optional[Dict[str, Any]]:
        """Get configuration for specific archetype"""
        return self.archetype_configs.get(archetype)
    
    def get_available_archetypes(self) -> List[str]:
        """Get list of available archetypes"""
        return list(self.archetype_configs.keys())


class ArchetypeResponseGenerator:
    """
    Generates context-aware responses using archetype-specific prompts and GPT-4o.
    
    Implements the unified response template with personality-specific variations.
    """
    
    def __init__(self, openai_client: OpenAI):
        self.client = openai_client
        self.config_loader = ArchetypeConfigLoader()
        self.timeout = 10  # Archetype responses can take longer than emotion analysis
    
    async def generate_response(
        self, 
        archetype: str, 
        text: str, 
        emotion_scores: EmotionScores,
        context: str = ""
    ) -> ArchetypeResponse:
        """
        Generate archetype-specific response for given text and context.
        
        Args:
            archetype: Name of archetype to use
            text: Original text to respond to
            emotion_scores: Emotion analysis results
            context: Additional context information
            
        Returns:
            ArchetypeResponse with generated advice
        """
        start_time = datetime.now()
        
        try:
            # Get archetype configuration
            config = self.config_loader.get_archetype_config(archetype)
            if not config:
                raise ValueError(f"Archetype configuration not found: {archetype}")
            
            # Prepare emotion levels for prompt
            emotion_levels = self._get_emotion_levels(emotion_scores)
            
            # Format the archetype prompt
            formatted_prompt = config['prompt'].format(
                text=text,
                context=context or "Нет дополнительного контекста",
                sarcasm_level=emotion_levels['sarcasm'],
                toxicity_level=emotion_levels['toxicity'],
                manipulation_level=emotion_levels['manipulation']
            )
            
            # Generate response using GPT-4o
            response_text = await self._make_api_call(formatted_prompt, config)
            
            # Parse response into structured format
            responses, signature = self._parse_archetype_response(response_text, archetype)
            
            processing_time = (datetime.now() - start_time).total_seconds()
            
            logger.info(f"{archetype} response generated in {processing_time:.3f}s")
            
            return ArchetypeResponse(
                archetype=archetype,
                responses=responses,
                signature=signature,
                processing_time=processing_time
            )
            
        except Exception as e:
            processing_time = (datetime.now() - start_time).total_seconds()
            error_msg = f"{archetype} response generation failed: {str(e)}"
            logger.error(f"{error_msg} (after {processing_time:.3f}s)")
            
            return ArchetypeResponse(
                archetype=archetype,
                responses=[],
                signature="",
                processing_time=processing_time,
                error_message=error_msg
            )
    
    async def _make_api_call(self, prompt: str, config: Dict[str, Any]) -> str:
        """Make GPT-4o API call for archetype response generation"""
        try:
            response = await asyncio.wait_for(
                self._sync_api_call(prompt, config),
                timeout=self.timeout
            )
            return response
            
        except asyncio.TimeoutError:
            raise Exception(f"Archetype response timeout after {self.timeout}s")
        except openai.RateLimitError:
            raise Exception("OpenAI rate limit exceeded")
        except openai.APIError as e:
            raise Exception(f"OpenAI API error: {str(e)}")
        except Exception as e:
            raise Exception(f"Unexpected error during API call: {str(e)}")
    
    async def _sync_api_call(self, prompt: str, config: Dict[str, Any]) -> str:
        """Synchronous OpenAI API call wrapped for async usage"""
        def make_call():
            response = self.client.chat.completions.create(
                model=config.get('model', 'gpt-4o'),
                messages=[
                    {
                        "role": "system",
                        "content": f"Ты архетип {config['name']} - {config['description']}"
                    },
                    {"role": "user", "content": prompt}
                ],
                max_tokens=config.get('max_tokens', 800),
                temperature=config.get('temperature', 0.7),
                timeout=config.get('timeout', 10)
            )
            content = response.choices[0].message.content
            return content.strip() if content else ""
        
        # Run in thread pool to avoid blocking
        loop = asyncio.get_event_loop()
        return await loop.run_in_executor(None, make_call)
    
    def _get_emotion_levels(self, emotion_scores: EmotionScores) -> Dict[str, str]:
        """Convert emotion scores to Russian level descriptions"""
        if emotion_scores.error_message:
            return {'sarcasm': 'ошибка', 'toxicity': 'ошибка', 'manipulation': 'ошибка'}
        
        def score_to_level(score: float) -> str:
            if score >= 0.7:
                return 'высокий'
            elif score >= 0.4:
                return 'средний'
            else:
                return 'низкий'
        
        return {
            'sarcasm': score_to_level(emotion_scores.sarcasm),
            'toxicity': score_to_level(emotion_scores.toxicity),
            'manipulation': score_to_level(emotion_scores.manipulation)
        }
    
    def _parse_archetype_response(self, response_text: str, archetype: str) -> Tuple[List[str], str]:
        """
        Parse archetype response into structured format.
        
        Expected format:
        🤖 **[ARCHETYPE] советует**:
        
        1. [Response 1]
        2. [Response 2]
        3. [Response 3]
        
        *[Signature phrase]*
        """
        try:
            lines = response_text.strip().split('\n')
            responses = []
            signature = ""
            
            # Extract numbered responses
            for line in lines:
                line = line.strip()
                if line.startswith(('1.', '2.', '3.')):
                    # Remove numbering and clean up
                    response = line[2:].strip()
                    if response:
                        responses.append(response)
                elif line.startswith('*') and line.endswith('*'):
                    # Extract signature phrase
                    signature = line[1:-1].strip()
            
            # Ensure we have 2-3 responses as specified
            if len(responses) < 2:
                # Fallback: split the entire response
                responses = [response_text.strip()]
            elif len(responses) > 3:
                # Keep only first 3 responses
                responses = responses[:3]
            
            # Default signature if not found
            if not signature:
                signature_map = {
                    'EMPATH': 'С теплом и пониманием 💚',
                    'META-SAGE': 'С мудростью веков 🔮',
                    'TRICKSTER': 'С игривым подмигиванием 😉',
                    'CRAZY-WISDOM': 'В дзен-парадоксе истина ☯️'
                }
                signature = signature_map.get(archetype, '')
            
            return responses, signature
            
        except Exception as e:
            logger.warning(f"Failed to parse {archetype} response: {e}")
            # Return the raw response as a single item
            return [response_text.strip()], ""


class ArchetypeSystem:
    """
    Main archetype system that combines selection and response generation.
    
    Provides high-level interface for the complete archetype workflow.
    """
    
    def __init__(self, openai_client: OpenAI):
        self.selector = ArchetypeSelector()
        self.generator = ArchetypeResponseGenerator(openai_client)
    
    async def get_auto_suggestion(self, emotion_scores: EmotionScores) -> Tuple[str, str]:
        """
        Get auto-suggested archetype and reason based on emotion scores.
        
        Returns:
            Tuple of (archetype_name, selection_reason)
        """
        return self.selector.select_archetype(emotion_scores)
    
    async def generate_archetype_response(
        self,
        archetype: str,
        text: str,
        emotion_scores: EmotionScores,
        context: str = ""
    ) -> ArchetypeResponse:
        """
        Generate response using specified archetype.
        
        Args:
            archetype: Archetype to use (EMPATH, META-SAGE, TRICKSTER, CRAZY-WISDOM)
            text: Original text to respond to
            emotion_scores: Emotion analysis results
            context: Additional context
            
        Returns:
            ArchetypeResponse with generated advice
        """
        return await self.generator.generate_response(archetype, text, emotion_scores, context)
    
    def get_available_archetypes(self) -> List[str]:
        """Get list of available archetypes"""
        return self.generator.config_loader.get_available_archetypes()
    
    def get_archetype_button_info(self) -> Dict[str, Dict[str, str]]:
        """Get button information for manual archetype selection"""
        return self.selector.get_archetype_button_info()


# Factory function for easy integration
def create_archetype_system(openai_client: OpenAI) -> ArchetypeSystem:
    """Create configured ArchetypeSystem instance"""
    return ArchetypeSystem(openai_client) 
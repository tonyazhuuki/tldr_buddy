#!/usr/bin/env python3
"""
Telegram Voice-to-Insight Pipeline
Main bot application with aiogram 3
"""

import asyncio
import logging
import os
import sys
from datetime import datetime
from pathlib import Path

from aiogram import Bot, Dispatcher, types, F
from aiogram.filters import Command
from aiogram.types import Message, ErrorEvent
from aiogram.webhook.aiohttp_server import SimpleRequestHandler, setup_application
from aiohttp import web
from dotenv import load_dotenv

# Import speech processing modules
from speech_pipeline import SpeechPipelineFactory, SpeechPipelineError

# Import text processing
from text_processor import TextProcessor

# Import process management for single-instance enforcement
from process_manager import enforce_single_instance

# Load environment variables
load_dotenv()

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('logs/bot.log'),
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger(__name__)

# Bot configuration
TELEGRAM_TOKEN = os.getenv('TELEGRAM_TOKEN')
if not TELEGRAM_TOKEN:
    logger.error("TELEGRAM_TOKEN environment variable not set")
    sys.exit(1)

# Initialize bot and dispatcher
bot = Bot(token=TELEGRAM_TOKEN)
dp = Dispatcher()

# Global speech pipeline instance
speech_pipeline = None
text_processor = None


@dp.message(Command("start"))
async def cmd_start(message: Message):
    """Handle /start command"""
    welcome_text = """
üéôÔ∏è **Telegram Voice-to-Insight Pipeline**

–ü—Ä–∏–≤–µ—Ç! –Ø –±–æ—Ç –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ –≥–æ–ª–æ—Å–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –ò–ò.

**–í–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏:**
‚Ä¢ üé§ –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ —Ä–µ—á–∏ –≤ —Ç–µ–∫—Å—Ç (faster-whisper)
‚Ä¢ üß† –ê–Ω–∞–ª–∏–∑ —Å–æ–¥–µ—Ä–∂–∞–Ω–∏—è —Å –ø–æ–º–æ—â—å—é LLM
‚Ä¢ üé≠ –ê–Ω–∞–ª–∏–∑ —Ç–æ–Ω–∞ –∏ —ç–º–æ—Ü–∏–π
‚Ä¢ üåç –ü–æ–¥–¥–µ—Ä–∂–∫–∞ —Ä—É—Å—Å–∫–æ–≥–æ –∏ –∞–Ω–≥–ª–∏–π—Å–∫–æ–≥–æ —è–∑—ã–∫–æ–≤
‚Ä¢ ‚ö° –ë—ã—Å—Ç—Ä–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ (‚â§2 —Å–µ–∫—É–Ω–¥—ã –¥–ª—è –º–∏–Ω—É—Ç–Ω–æ–≥–æ –∞—É–¥–∏–æ)

**–ö–æ–º–∞–Ω–¥—ã:**
/start - –ü–æ–∫–∞–∑–∞—Ç—å —ç—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ
/help - –°–ø—Ä–∞–≤–∫–∞ –ø–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é
/health - –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Å—Ç–∞—Ç—É—Å —Å–∏—Å—Ç–µ–º—ã
/stats - –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏

**–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ:**
–ü—Ä–æ—Å—Ç–æ –ø–µ—Ä–µ—à–ª–∏—Ç–µ –º–Ω–µ –≥–æ–ª–æ—Å–æ–≤–æ–µ –∏–ª–∏ –≤–∏–¥–µ–æ —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞!
"""
    await message.answer(welcome_text, parse_mode="Markdown")


@dp.message(Command("help"))
async def cmd_help(message: Message):
    """Handle /help command"""
    help_text = """
üìñ **–°–ø—Ä–∞–≤–∫–∞ –ø–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é**

**–û—Å–Ω–æ–≤–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏:**
1. **–ê–Ω–∞–ª–∏–∑ –≥–æ–ª–æ—Å–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π** - –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –≤–æ–π—Å –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Ç–µ–∫—Å—Ç–∞
2. **–ê–Ω–∞–ª–∏–∑ –≤–∏–¥–µ–æ —Å–æ–æ–±—â–µ–Ω–∏–π** - –ø–æ–¥–¥–µ—Ä–∂–∫–∞ –∫—Ä—É–≥–ª—ã—Ö –≤–∏–¥–µ–æ —Å –∞—É–¥–∏–æ
3. **–£–º–Ω–æ–µ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ —è–∑—ã–∫–∞** - –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ä—É—Å—Å–∫–æ–≥–æ/–∞–Ω–≥–ª–∏–π—Å–∫–æ–≥–æ
4. **–û–±—É—á–µ–Ω–∏–µ –ø—Ä–µ–¥–ø–æ—á—Ç–µ–Ω–∏—è–º** - —Å–∏—Å—Ç–µ–º–∞ –∑–∞–ø–æ–º–∏–Ω–∞–µ—Ç –≤–∞—à —è–∑—ã–∫ –¥–ª—è —É—Å–∫–æ—Ä–µ–Ω–∏—è

**–¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏:**
‚Ä¢ –ò—Å–ø–æ–ª—å–∑—É–µ—Ç faster-whisper –¥–ª—è –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–π —Ç–æ—á–Ω–æ—Å—Ç–∏
‚Ä¢ –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω –¥–ª—è –±—ã—Å—Ç—Ä–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏
‚Ä¢ –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç —Ä–∞–∑–ª–∏—á–Ω—ã–µ –∞—É–¥–∏–æ—Ñ–æ—Ä–º–∞—Ç—ã (OGG, MP3, MP4, WAV)
‚Ä¢ –ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –¥–ª—è –ø–æ–≤—Ç–æ—Ä–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤

**–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–µ —Ñ–æ—Ä–º–∞—Ç—ã:**
‚Ä¢ –ì–æ–ª–æ—Å–æ–≤—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è Telegram (OGG Opus) ‚ö° –±—ã—Å—Ç—Ä–æ
‚Ä¢ –ê—É–¥–∏–æ—Ñ–∞–π–ª—ã MP3, MP4, WAV üîÑ —Å –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–µ–π
‚Ä¢ –í–∏–¥–µ–æ —Å–æ–æ–±—â–µ–Ω–∏—è —Å –∞—É–¥–∏–æ–¥–æ—Ä–æ–∂–∫–æ–π

–ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞: 50 –ú–ë
–ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å: 10 –º–∏–Ω—É—Ç
"""
    await message.answer(help_text, parse_mode="Markdown")


@dp.message(Command("health"))
async def cmd_health(message: Message):
    """Handle /health command"""
    try:
        if not speech_pipeline:
            await message.answer("‚ùå –°–∏—Å—Ç–µ–º–∞ —Ä–µ—á–µ–≤–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏ –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞")
            return
        
        health_status = await speech_pipeline.health_check()
        
        if health_status['status'] == 'healthy':
            status_text = "‚úÖ **–°–∏—Å—Ç–µ–º–∞ —Ä–∞–±–æ—Ç–∞–µ—Ç –Ω–æ—Ä–º–∞–ª—å–Ω–æ**\n\n"
        else:
            status_text = "‚ö†Ô∏è **–û–±–Ω–∞—Ä—É–∂–µ–Ω—ã –ø—Ä–æ–±–ª–µ–º—ã**\n\n"
        
        for component, info in health_status['components'].items():
            status_icon = "‚úÖ" if info['status'] == 'healthy' else "‚ùå"
            status_text += f"{status_icon} **{component}**: {info['message']}\n"
        
        await message.answer(status_text, parse_mode="Markdown")
        
    except Exception as e:
        logger.error(f"Health check failed: {e}")
        await message.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ —Å—Ç–∞—Ç—É—Å–∞ —Å–∏—Å—Ç–µ–º—ã")


@dp.message(Command("stats"))
async def cmd_stats(message: Message):
    """Handle /stats command"""
    try:
        if not speech_pipeline:
            await message.answer("‚ùå –°–∏—Å—Ç–µ–º–∞ —Ä–µ—á–µ–≤–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏ –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞")
            return
        
        metrics = speech_pipeline.get_performance_metrics()
        
        stats_text = f"""
üìä **–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏**

**–û–±—â–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:**
‚Ä¢ –í—Å–µ–≥–æ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–æ: {metrics['total_processed']}
‚Ä¢ –£—Å–ø–µ—à–Ω–æ: {metrics['success_count']}
‚Ä¢ –û—à–∏–±–æ–∫: {metrics['error_count']}
‚Ä¢ –£—Å–ø–µ—à–Ω–æ—Å—Ç—å: {metrics['success_rate']:.1%}

**–ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å:**
‚Ä¢ –°—Ä–µ–¥–Ω–µ–µ –≤—Ä–µ–º—è –æ–±—Ä–∞–±–æ—Ç–∫–∏: {metrics['average_total_time']:.2f}—Å
‚Ä¢ –í—Ä–µ–º—è –∞—É–¥–∏–æ–æ–±—Ä–∞–±–æ—Ç–∫–∏: {metrics['average_audio_time']:.2f}—Å  
‚Ä¢ –í—Ä–µ–º—è —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è: {metrics['average_speech_time']:.2f}—Å
‚Ä¢ –¶–µ–ª—å ‚â§2—Å: {"‚úÖ" if metrics['performance_target_met'] else "‚ùå"}
"""
        
        await message.answer(stats_text, parse_mode="Markdown")
        
    except Exception as e:
        logger.error(f"Stats command failed: {e}")
        await message.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏")


@dp.message(F.voice)
async def handle_voice_message(message: Message):
    """Handle voice messages with speech processing pipeline"""
    try:
        if not message.voice:
            await message.reply("‚ùå –û—à–∏–±–∫–∞: –ì–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ")
            return
            
        if not message.from_user:
            await message.reply("‚ùå –û—à–∏–±–∫–∞: –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞")
            return
            
        user_id = str(message.from_user.id)
        file_id = message.voice.file_id
        duration = message.voice.duration
        
        logger.info(f"Received voice message from user {user_id}, "
                   f"duration: {duration}s, file_id: {file_id}")
        
        # Send processing notification
        processing_msg = await message.answer("üéôÔ∏è –û–±—Ä–∞–±–∞—Ç—ã–≤–∞—é –≥–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ...")
        
        if not speech_pipeline:
            await processing_msg.edit_text("‚ùå –°–∏—Å—Ç–µ–º–∞ —Ä–µ—á–µ–≤–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏ –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞")
            return
        
        # Process voice message through pipeline
        try:
            transcribed_text = await speech_pipeline.process_voice_message(
                file_id, user_id, bot=bot, chat_id=str(message.chat.id)
            )
            
            # Update processing message
            await processing_msg.edit_text("üîÑ –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º —Å–æ–¥–µ—Ä–∂–∞–Ω–∏–µ...")
            
            # Process text through DEFAULT and TONE modes
            if text_processor:
                try:
                    processing_result = await text_processor.process_parallel(transcribed_text)
                    formatted_output = text_processor.format_output(processing_result)
                    
                    # Edit the processing message with final result
                    await processing_msg.edit_text(formatted_output, parse_mode="Markdown")
                    
                except Exception as text_error:
                    logger.error(f"Text processing error: {text_error}")
                    # Fallback to transcription only
                    fallback_text = f"""
üìù **–†–µ–∑—É–ª—å—Ç–∞—Ç —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è —Ä–µ—á–∏**

**–¢–µ–∫—Å—Ç:**
{transcribed_text}

‚ö†Ô∏è –ê–Ω–∞–ª–∏–∑ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω (–æ—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏)
‚è±Ô∏è –û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞
"""
                    await processing_msg.edit_text(fallback_text, parse_mode="Markdown")
            else:
                # Text processor not initialized - fallback to transcription only
                fallback_text = f"""
üìù **–†–µ–∑—É–ª—å—Ç–∞—Ç —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è —Ä–µ—á–∏**

**–¢–µ–∫—Å—Ç:**
{transcribed_text}

‚ö†Ô∏è –ê–Ω–∞–ª–∏–∑ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω (–ø—Ä–æ—Ü–µ—Å—Å–æ—Ä –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω)
‚è±Ô∏è –û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞
"""
                await processing_msg.edit_text(fallback_text, parse_mode="Markdown")
            
        except SpeechPipelineError as e:
            logger.error(f"Speech pipeline error: {e}")
            
            # Check if user was already notified to avoid duplicate messages
            if hasattr(e, 'user_notified') and e.user_notified:
                # User already received the error message directly, just clean up
                await processing_msg.delete()
            else:
                # Normal error handling - send error message
                await processing_msg.edit_text(
                    f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ: {str(e)}\n\n"
                    "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑ –∏–ª–∏ –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É."
                )
            
    except Exception as e:
        logger.error(f"Error processing voice message: {e}")
        await message.answer("‚ùå –ù–µ–æ–∂–∏–¥–∞–Ω–Ω–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è")


@dp.message(F.video_note)
async def handle_video_note(message: Message):
    """Handle video notes (–∫—Ä—É–≥–ª—ã–µ –≤–∏–¥–µ–æ)"""
    try:
        if not message.video_note:
            await message.reply("‚ùå –û—à–∏–±–∫–∞: –í–∏–¥–µ–æ —Å–æ–æ–±—â–µ–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ")
            return
            
        if not message.from_user:
            await message.reply("‚ùå –û—à–∏–±–∫–∞: –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞")
            return
            
        user_id = str(message.from_user.id)
        file_id = message.video_note.file_id
        duration = message.video_note.duration
        
        logger.info(f"Received video note from user {user_id}, "
                   f"duration: {duration}s, file_id: {file_id}")
        
        processing_msg = await message.answer("üé• –û–±—Ä–∞–±–∞—Ç—ã–≤–∞—é –≤–∏–¥–µ–æ —Å–æ–æ–±—â–µ–Ω–∏–µ...")
        
        if not speech_pipeline:
            await processing_msg.edit_text("‚ùå –°–∏—Å—Ç–µ–º–∞ —Ä–µ—á–µ–≤–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏ –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞")
            return
        
        # Process video note through the same pipeline (audio extraction handled internally)
        try:
            transcribed_text = await speech_pipeline.process_voice_message(
                file_id, user_id, bot=bot, chat_id=str(message.chat.id)
            )
            
            # Update processing message
            await processing_msg.edit_text("üîÑ –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º —Å–æ–¥–µ—Ä–∂–∞–Ω–∏–µ...")
            
            # Process text through DEFAULT and TONE modes
            if text_processor:
                try:
                    processing_result = await text_processor.process_parallel(transcribed_text)
                    formatted_output = text_processor.format_output(processing_result)
                    
                    # Edit the processing message with final result
                    await processing_msg.edit_text(formatted_output, parse_mode="Markdown")
                    
                except Exception as text_error:
                    logger.error(f"Text processing error: {text_error}")
                    # Fallback to transcription only
                    fallback_text = f"""
üìù **–†–µ–∑—É–ª—å—Ç–∞—Ç —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è –≤–∏–¥–µ–æ —Å–æ–æ–±—â–µ–Ω–∏—è**

**–¢–µ–∫—Å—Ç:**
{transcribed_text}

‚ö†Ô∏è –ê–Ω–∞–ª–∏–∑ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω (–æ—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏)
‚è±Ô∏è –û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞
"""
                    await processing_msg.edit_text(fallback_text, parse_mode="Markdown")
            else:
                # Text processor not initialized - fallback to transcription only
                fallback_text = f"""
üìù **–†–µ–∑—É–ª—å—Ç–∞—Ç —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è –≤–∏–¥–µ–æ —Å–æ–æ–±—â–µ–Ω–∏—è**

**–¢–µ–∫—Å—Ç:**
{transcribed_text}

‚ö†Ô∏è –ê–Ω–∞–ª–∏–∑ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω (–ø—Ä–æ—Ü–µ—Å—Å–æ—Ä –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω)
‚è±Ô∏è –û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞
"""
                await processing_msg.edit_text(fallback_text, parse_mode="Markdown")
            
        except SpeechPipelineError as e:
            logger.error(f"Video note processing error: {e}")
            
            # Check if user was already notified to avoid duplicate messages  
            if hasattr(e, 'user_notified') and e.user_notified:
                # User already received the error message directly, just clean up
                await processing_msg.delete()
            else:
                # Normal error handling - send error message
                await processing_msg.edit_text(
                    f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –≤–∏–¥–µ–æ: {str(e)}\n\n"
                    "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑ –∏–ª–∏ –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É."
                )
            
    except Exception as e:
        logger.error(f"Error processing video note: {e}")
        await message.answer("‚ùå –ù–µ–æ–∂–∏–¥–∞–Ω–Ω–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –≤–∏–¥–µ–æ —Å–æ–æ–±—â–µ–Ω–∏—è")


@dp.message(Command("list_modes"))
async def cmd_list_modes(message: Message):
    """Handle /list_modes command"""
    modes_text = """
üîß **–†–µ–∂–∏–º—ã –æ–±—Ä–∞–±–æ—Ç–∫–∏**

**–¢–µ–∫—É—â–∏–π —Ä–µ–∂–∏–º:** Speech-to-Text
‚Ä¢ –ò—Å–ø–æ–ª—å–∑—É–µ—Ç faster-whisper –¥–ª—è —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è —Ä–µ—á–∏
‚Ä¢ –ü–æ–¥–¥–µ—Ä–∂–∫–∞ —Ä—É—Å—Å–∫–æ–≥–æ –∏ –∞–Ω–≥–ª–∏–π—Å–∫–æ–≥–æ —è–∑—ã–∫–æ–≤
‚Ä¢ –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —è–∑—ã–∫–∞
‚Ä¢ –û–±—É—á–µ–Ω–∏–µ —è–∑—ã–∫–æ–≤—ã–º –ø—Ä–µ–¥–ø–æ—á—Ç–µ–Ω–∏—è–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è

**–ü–ª–∞–Ω–∏—Ä—É–µ–º—ã–µ —Ä–µ–∂–∏–º—ã:**
‚Ä¢ LLM –∞–Ω–∞–ª–∏–∑ —Å–æ–¥–µ—Ä–∂–∞–Ω–∏—è (GPT-4)
‚Ä¢ –¢–æ–Ω–∞–ª—å–Ω—ã–π –∞–Ω–∞–ª–∏–∑ —ç–º–æ—Ü–∏–π
‚Ä¢ –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –∫–ª—é—á–µ–≤—ã—Ö –ø—É–Ω–∫—Ç–æ–≤
‚Ä¢ –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º—ã–µ —Ä–µ–∂–∏–º—ã –æ–±—Ä–∞–±–æ—Ç–∫–∏

–°–ª–µ–¥–∏—Ç–µ –∑–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è–º–∏!
"""
    await message.answer(modes_text, parse_mode="Markdown")


@dp.message(Command("set_model"))
async def cmd_set_model(message: Message):
    """Handle /set_model command"""
    info_text = """
üîß **–ù–∞—Å—Ç—Ä–æ–π–∫–∞ –º–æ–¥–µ–ª–µ–π**

–§—É–Ω–∫—Ü–∏—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –º–æ–¥–µ–ª–µ–π –±—É–¥–µ—Ç –¥–æ—Å—Ç—É–ø–Ω–∞ –≤ —Å–ª–µ–¥—É—é—â–∏—Ö –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è—Ö.

**–ü–ª–∞–Ω–∏—Ä—É–µ–º—ã–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏:**
‚Ä¢ –í—ã–±–æ—Ä —Ä–∞–∑–º–µ—Ä–∞ –º–æ–¥–µ–ª–∏ Whisper (base/small/medium)
‚Ä¢ –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —è–∑—ã–∫–æ–≤—ã—Ö –ø—Ä–µ–¥–ø–æ—á—Ç–µ–Ω–∏–π
‚Ä¢ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–µ —Ä–µ–∂–∏–º—ã –æ–±—Ä–∞–±–æ—Ç–∫–∏
‚Ä¢ –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –∫–∞—á–µ—Å—Ç–≤–∞ vs —Å–∫–æ—Ä–æ—Å—Ç–∏

–¢–µ–∫—É—â–∞—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–∞ –¥–ª—è –ª—É—á—à–µ–≥–æ –±–∞–ª–∞–Ω—Å–∞ —Å–∫–æ—Ä–æ—Å—Ç–∏ –∏ –∫–∞—á–µ—Å—Ç–≤–∞.
"""
    await message.answer(info_text, parse_mode="Markdown")


@dp.error()
async def error_handler(event: ErrorEvent):
    """Global error handler"""
    logger.error(f"Update {event.update} caused error {event.exception}")


# Health check endpoint for Docker
async def health_check(request):
    """Health check endpoint"""
    try:
        # Simple health check - just return OK if server is running
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        bot_status = 'running'
        pipeline_status = 'ready' if speech_pipeline else 'initializing'
        pipeline_details = ""
        
        # Try to check speech pipeline if available
        if speech_pipeline:
            try:
                health_result = await speech_pipeline.health_check()
                pipeline_details = f"\nüîç Details: {health_result.get('status', 'unknown')}"
            except Exception as e:
                pipeline_details = f"\n‚ö†Ô∏è Warning: {str(e)}"
                logger.warning(f"Pipeline health check failed: {e}")
        
        return web.Response(
            text=f"‚úÖ Bot Status: healthy\n"
                 f"üìÖ Time: {timestamp}\n"
                 f"ü§ñ Telegram: {bot_status}\n"
                 f"üé§ Pipeline: {pipeline_status}{pipeline_details}\n"
                 f"üåê Ready to receive webhooks!",
            status=200
        )
        
    except Exception as e:
        logger.error(f"Health check failed: {e}")
        return web.Response(
            text=f"‚ùå Health check error: {str(e)}\n"
                 f"üìÖ Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
                 f"‚ÑπÔ∏è  This is a temporary error",
            status=500
        )


async def startup():
    """Initialize speech processing pipeline on startup"""
    global speech_pipeline, text_processor
    
    try:
        logger.info("=== STARTUP INITIALIZATION ===")
        
        # Check environment variables
        telegram_token = os.getenv("TELEGRAM_TOKEN")
        openai_api_key = os.getenv("OPENAI_API_KEY")
        webhook_url = os.getenv("WEBHOOK_URL")
        port = os.getenv("PORT")
        
        logger.info(f"Environment check:")
        logger.info(f"- TELEGRAM_TOKEN: {'‚úì Set' if telegram_token else '‚úó Missing'}")
        logger.info(f"- OPENAI_API_KEY: {'‚úì Set' if openai_api_key else '‚úó Missing'}")
        logger.info(f"- WEBHOOK_URL: {webhook_url if webhook_url else 'Not set (polling mode)'}")
        logger.info(f"- PORT: {port if port else 'Default'}")
        
        if not openai_api_key:
            raise ValueError("OPENAI_API_KEY not found in environment variables")
        
        logger.info("Initializing speech processing pipeline...")
        
        # Create speech pipeline (this will load the Whisper model)
        speech_pipeline = await SpeechPipelineFactory.create_pipeline(bot, redis_client=None)
        
        logger.info("‚úì Speech processing pipeline initialized successfully")
        
        # Initialize text processor
        logger.info("Initializing text processor...")
        text_processor = TextProcessor(openai_api_key)
        logger.info("‚úì Text processor initialized successfully")
        
        logger.info("=== STARTUP COMPLETED SUCCESSFULLY ===")
        
    except Exception as e:
        logger.error(f"‚úó Failed to initialize: {e}")
        logger.exception("Full error details:")
        logger.error("Bot will start but speech processing will be unavailable")


async def on_startup():
    """Startup actions"""
    await startup()
    # Set webhook if WEBHOOK_URL is provided
    webhook_url = os.getenv('WEBHOOK_URL')
    if webhook_url:
        await bot.set_webhook(webhook_url)
        logger.info(f"Webhook set to {webhook_url}")


async def main():
    """Main bot function"""
    logger.info("Starting Telegram Voice-to-Insight Pipeline Bot...")
    
    # Check if we should use webhook or polling
    webhook_url = os.getenv('WEBHOOK_URL')
    port = int(os.getenv('PORT', 8000))
    
    logger.info(f"Configuration:")
    logger.info(f"- Mode: {'Webhook' if webhook_url else 'Polling'}")
    logger.info(f"- Port: {port}")
    logger.info(f"- Webhook URL: {webhook_url}")
    
    if webhook_url:
        # Webhook mode for Railway
        logger.info(f"üöÄ Starting in webhook mode on port {port}")
        
        try:
            # Initialize speech processing
            await startup()
            
            # Create aiohttp app
            app = web.Application()
            
            # Add health check route FIRST
            app.router.add_get('/health', health_check)
            logger.info("‚úì Health check route added")
            
            # Add root route for basic check
            async def root_handler(request):
                return web.Response(text="Telegram Bot is running", status=200)
            app.router.add_get('/', root_handler)
            logger.info("‚úì Root route added")
            
            # Setup webhook
            webhook_path = '/webhook'
            app.router.add_post(webhook_path, SimpleRequestHandler(dispatcher=dp, bot=bot).handle)
            logger.info("‚úì Webhook route added")
            
            # Start server BEFORE setting webhook
            runner = web.AppRunner(app)
            await runner.setup()
            site = web.TCPSite(runner, '0.0.0.0', port)
            await site.start()
            
            logger.info(f"‚úÖ Server started successfully on 0.0.0.0:{port}")
            
            # Set webhook AFTER server is running
            full_webhook_url = f"{webhook_url}{webhook_path}"
            await bot.set_webhook(full_webhook_url)
            logger.info(f"‚úÖ Webhook set to {full_webhook_url}")
            
            # Keep the server running
            logger.info("üîÑ Server is running and ready to receive requests...")
            try:
                while True:
                    await asyncio.sleep(60)  # Check every minute
                    logger.info("üíì Server heartbeat")
            except KeyboardInterrupt:
                logger.info("üõë Shutdown requested")
            finally:
                logger.info("üßπ Cleaning up...")
                await bot.delete_webhook()
                await runner.cleanup()
                
        except Exception as e:
            logger.error(f"üí• Failed to start webhook server: {e}")
            logger.exception("Full error:")
            raise
            
    else:
        # Polling mode for local development
        logger.info("üîÑ Starting in polling mode")
        
        # Initialize speech processing
        await startup()
        
        # Start polling
        await dp.start_polling(bot)


if __name__ == "__main__":
    # Skip single instance enforcement in production (Railway)
    is_production = os.getenv('RAILWAY_ENVIRONMENT') or os.getenv('WEBHOOK_URL')
    
    if not is_production:
        # Enforce single instance only in local development
        try:
            logger.info("–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è single-instance enforcement...")
            process_manager = enforce_single_instance(auto_cleanup=True, force_cleanup=False)
            logger.info("‚úÖ Single-instance enforcement –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω")
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ process manager: {e}")
            process_manager = None
    else:
        logger.info("Production environment detected, skipping single-instance enforcement")
        process_manager = None
    
    try:
        # Start the bot
        asyncio.run(main())
        
    except KeyboardInterrupt:
        logger.info("–ü–æ–ª—É—á–µ–Ω —Å–∏–≥–Ω–∞–ª –æ—Å—Ç–∞–Ω–æ–≤–∫–∏, –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Ä–∞–±–æ—Ç—ã...")
    except Exception as e:
        logger.error(f"–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –±–æ—Ç–∞: {e}")
        sys.exit(1)
    finally:
        # Ensure process manager cleanup
        if process_manager:
            try:
                process_manager.release_lock()
                logger.info("‚úÖ Process manager –æ—á–∏—â–µ–Ω")
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—á–∏—Å—Ç–∫–µ process manager: {e}") 